// Есть модули, которые можно использовать глобально,такие как module.exports, process, а есть такие, которые необходимо подключать
// require - как он работает, он берет, файл, который нужно подключить, и делает его в обертке какой-либо функции, и туда он может некоторые модули самостоятельно отправлять и пробрасывает, в результате чего они становятся глобальными (это например м.б. console, process) и ими можно пользоваться сразу
// OS MODULE - информация об операционной системе
// os.cpus() Возвращает массив объектов, содержащий информацию о каждом логическом ядре: os.cpus().length - количество ядер
const os = require("os");
// console.log(os.cpus().length);

// PATH MODULE
const path = require("path");

//1) path.resolve Метод решает последовательность путей или сегментов пути в абсолютный путь
// console.log(path.resolve("wwwroot", "static_files/png/", "../gif/image.gif"));
// If the current working directory is /home/myself/node,
// this returns '/home/myself/node/wwwroot/static_files/gif/image.gif'

//2) path.join() - соединяет пути, и есть возможность самостоятельно управлять соединением.  Более удобен, чем resolve. Если добавить __dirname, получится тот же результат, что и с resolve
// path.join()Метод объединяет все заданные path-сегменты вместе с использованием платформы конкретного разделителя в качестве разделителя, а затем нормализует получившийся путь.
// console.log(path.join(__dirname, "/foo", "bar", "baz/asdf", "quux", ".."));
// Returns: '/foo/bar/baz/asdf');

//3) path.parse(path) - удобен, чтобы получить расширение файла

// PROCESS MODULE - подключается напрямую. У него есть события, которые произошли
//1) Event: 'unhandledRejection' - обрабатывает асинхронные ошибки. Если, к примеру, какой-то promise  не вернул ответ, забыли поставить await, если на следующих nextTick происходит ошибка - это событие позволяет отловить когда, что, где произошло
// process.on("unhandledRejection", (reason, promise) => {
//   console.log("Unhandled Rejection at:", promise, "reason:", reason);
//   // Application specific logging, throwing an error, or other logic here
// });

//2) process.argv - позволяет построить и написать консольное приложение
// В process.argvвозвращает свойство массив , содержащий аргументы командной строки , передается , когда был запущен процесс Node.js. Первый элемент будет process.execPath. Посмотрите, нужен process.argv0ли доступ к исходному значению argv[0]. Второй элемент - это путь к исполняемому файлу JavaScript. Остальные элементы будут любыми дополнительными аргументами командной строки.
// [0] - всегда идет строка, где находится node
// [1] - строка, где находится скрипт, который мы запустили
// [2...и далее] - строки с информацией, которую мы укажем при запуске
// console.log(process.argv);

// 3) process.cwd() - Метод возвращает текущий рабочий каталог процесса Node.js
// Разница между process.argv, __dirname и process.cwd() - если запускать в текущем файле - разницы между ними нет, но если выйти на уровень выше (cd..) и запустить команду для открытия текущего файла node main.js - тогда эти методы изменяться: __dirname - всегда укажет место, где находится запускаемый скрипт;  process.cwd() - место где был запущен скрипт. Через него удобно узнавать корень запуска скрипта
// console.log(process.cwd());

// 4) process.exit() - если произошла ошибка и необходимо завершить работу приложения. После него дальше ничего не выполняется. Если запускать без параметров - говорит о том, что ошибок не было; если произошла ошибка и нужно аврально завершить проиписываем process.exit(1).

//5) чтобы, к примеру, вывести код ошибки
process.on("exit", (code) => {
  console.log(code);
});

process.exit(1);
