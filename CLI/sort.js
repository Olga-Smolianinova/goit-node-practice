// разработка CLI-приложения. Сделаем сортировку картинок по папкам, в зависимости от их расширения.
// Файл сортировки. Прописана основная бизнес-логика

// MODULE
import fs from "fs/promises";
import path from "path";

// Data
import { isAccessible } from "./lib/accessible.js"; //функция для проверки

class SortFiles {
  // через конструктор указываем куда будем принимать и сортировать файлы
  constructor(dist) {
    // черз конструктор создаем переменную dist
    this.dist = dist;

    // И когда все готово создаем папку dist, чтобы была возможность сохранять туда и сортировать файлы
    // чтобы создать папку dist, поскольку мы создаем, а у нас promise, а конструктор не может быть асинхронный используем queueMicrotask, который рекомендуется использовать в ES, как альтернатива nextTick
    queueMicrotask(async () => {
      //  добавляем проверку, если папки dist нет, то нужно создать папку в папке dist
      if (!(await isAccessible(dist))) {
        await fs.mkdir(dist);
      }
    });
  }

  // асинхронный приватный метод для копирования файлов. Принимает file. Есть ограничения file не может быть более 1ГБ, в этом случае будет ошибка. Чтобы этого избежать используются потоки - специальные ограничения, поставленные для оперативной памяти, пробрасыватся через stream
  async #copyFile(file) {
    //куда мы будем складывать. path.extname - мы можем от имени файла взять расширение, оно идет с точкой, достаем его из file.path
    const folder = path.extname(file.path);

    // нужен итоговый путь. У нас есть папка dist, в которую нужно положить новую папку (folder). эти папки будут называться по расширению картинок .img, .png и т.д. Но мы будем ложить так dist/.img, dist/.png
    const targetPath = path.join(this.dist, folder);

    try {
      //  добавляем проверку, если папки targetPath нет, то нужно ее создать
      if (!(await isAccessible(targetPath))) {
        await fs.mkdir(targetPath);
      }
      // после чего вызываем метод fs.copyFile, если нужно перенести rename - он переносит; если нужно копировать - мы переносим с того пути, где он лежит file.path и перекидываем его на тот путь, который подготовили path.join(targetPath) и добавляем имя файла (file.name)
      await fs.copyFile(file.path, path.join(targetPath, file.name));
    } catch (e) {
      console.log(e.message);
      process.exit(1);
    }
  }

  // асинхронная функция, которая принимает базу. Считываем файлы fs.readdir и пробрасываем туда base, там будут лежать Files - и это просто массив строк. Если используем await, то про forEach - можно забыть и не стоит его использовать в таких случаях. Намного проще использовать просто for. base приходит из app.js ( await sorting.readFolder(resolve(__dirname, source)))
  async readFolder(base) {
    const files = await fs.readdir(base);
    for (const item of files) {
      //создаем локальные base - где лежат полные пути, такие как они должны быть. Используем path.join (и мы base, которая пришла и где лежат файлы соединяем с item )
      const localBase = path.join(base, item);

      // информация про файл, про папку можно можно использовать и получить с помощью Class: fs.Stats - это такой класс, у которого есть куча методов, будем использовать stats.isDirectory() или stats.isFile()
      // пробрасываем наш полный путь, создаем объект state, который должен прочитать это fs.stat(), в который пробрасываем localBase, т.е fs.stat(localBase) должен прочитать эту информацию и понять что это
      const state = await fs.stat(localBase);

      // добавляем проверку. Мы на state.isDirectory() рекурсивно базовый случай куда будем переносить в ветку if или в ветку else.
      // Рекурсия – это когда функция в своём теле вызывает саму себя. Функцию, которая вызывает сама себя, называют рекурсивной функцией. Вызов рекурсивной функции, называется рекурсивным вызовом. Выполнение программы многократно спускается вниз, пока не упрётся в условие выхода из рекурсии. Достигнув конца, она идёт обратно, возвращая результаты сделанных вызовов.
      //Базовый случай — это то, к чему должна стремиться рекурсия. По его достижению прекращается выполнение работы или вычисления, и полученный результат возвращается обратно
      if (state.isDirectory()) {
        //рекурсивно вызываем readFolder, но с учетом localBase, т.е. провалимся в новую папку рекурсивно
        await this.readFolder(localBase);
      } else {
        // в приватный метод передаем имя и путь
        await this.#copyFile({ name: item, path: localBase });
      }
    }
  }
}

export default SortFiles;
